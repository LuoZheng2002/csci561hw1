bool CoverTree::insert(CoverTree::Node* current, const pointType& p)
{
    bool result = false;
#ifdef DEBUG
    if (current->dist(p) > current->covdist())
        throw std::runtime_error("Internal insert got wrong input!");
    if (truncateLevel > 0 && current->level < maxScale - truncateLevel)
    {
        std::cout << maxScale;
        std::cout << " skipped" << std::endl;
        return false;
    }
#endif
    if (truncate_level > 0 && current->level < max_scale-truncate_level)
        return false;

    // acquire read lock
    current->mut.lock_shared();

    // Sort the children
    unsigned num_children = current->children.size();
    std::vector<int> idx(num_children);
    std::iota(std::begin(idx), std::end(idx), 0);
    std::vector<double> dists(num_children);
    for (unsigned i = 0; i < num_children; ++i)
        dists[i] = current->children[i]->dist(p);
    auto comp_x = [&dists](int a, int b) { return dists[a] < dists[b]; };
    std::sort(std::begin(idx), std::end(idx), comp_x);

    bool flag = true;
    for (const auto& child_idx : idx)
    {
        Node* child = current->children[child_idx];
        double dist_child = dists[child_idx];
        if (dist_child <= 0.0)
        {
            // release read lock then enter child
            current->mut.unlock_shared();
            flag = false;
            std::cout << "Duplicate entry!!!" << std::endl;
            break;
        }
        else if (dist_child <= child->covdist())
        {
            // release read lock then enter child
            if (child->maxdistUB < dist_child)
                child->maxdistUB = dist_child;
            current->mut.unlock_shared();
            result = insert(child, p);
            flag = false;
            break;
        }
    }

    if (flag)
    {
        // release read lock then acquire write lock
        current->mut.unlock_shared();
        current->mut.lock();
        // check if insert is still valid, i.e. no other point was inserted else restart
        if (num_children==current->children.size())
        {
            int new_id = ++N;
            current->setChild(p, new_id);
            result = true;
            current->mut.unlock();

            int local_min = min_scale.load();
            while( local_min > current->level - 1){
                min_scale.compare_exchange_weak(local_min, current->level - 1, std::memory_order_relaxed, std::memory_order_relaxed);
                local_min = min_scale.load();
            }
        }
        else
        {
            current->mut.unlock();
            result = insert(current, p);
        }
        //if (min_scale > current->level - 1)
        //{
            //min_scale = current->level - 1;
            ////std::cout << minScale << " " << maxScale << std::endl;
        //}
    }
    return result;
}